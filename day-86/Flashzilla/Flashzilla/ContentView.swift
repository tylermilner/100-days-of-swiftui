//
//  ContentView.swift
//  Flashzilla
//
//  Created by Tyler Milner on 11/11/23.
//

import CoreHaptics
import SwiftUI

// Supporting specific accessibility needs with SwiftUI
func withOptionalAnimation<Result>(_ animation: Animation? = .default, _ body: () throws -> Result) rethrows -> Result {
    if UIAccessibility.isReduceMotionEnabled {
        return try body()
    } else {
        return try withAnimation(animation, body)
    }
}

struct ContentView: View {
    // Differentiate without color
//    @Environment(\.accessibilityDifferentiateWithoutColor) var differentiateWithoutColor
    
    // Reduce motion
//    @Environment(\.accessibilityReduceMotion) var reduceMotion
//    @State private var scale = 1.0
    
    // Reduce transparency
    @Environment(\.accessibilityReduceTransparency) var reduceTransparency
    
    var body: some View {
        // Reduce transparency
        Text("Hello, world!")
            .padding()
            .background(reduceTransparency ? .black : .black.opacity(0.5))
            .foregroundColor(.white)
            .clipShape(Capsule())
        
        // Reduce motion
//        Text("Hello, world!")
//            .scaleEffect(scale)
//            .onTapGesture {
//                withOptionalAnimation {
//                    scale *= 1.5
//                }
//            }
        
        // Differentiate without color
//        HStack {
//            if differentiateWithoutColor {
//                Image(systemName: "checkmark.circle")
//            }
//            
//            Text("Success")
//        }
//        .padding()
//        .background(differentiateWithoutColor ? .black : .green)
//        .foregroundColor(.white)
//        .clipShape(Capsule())
    }
}

//// How to be notified when your SwiftUI app moves to the background
//struct ContentView: View {
//    @Environment(\.scenePhase) var scenePhase
//    
//    var body: some View {
//        Text("Hello")
//            .padding()
//            .onChange(of: scenePhase) { oldValue, newPhase in
//                if newPhase == .active {
//                    print("Active")
//                } else if newPhase == .inactive {
//                    print("Inactive")
//                } else if newPhase == .background {
//                    print("Background")
//                }
//            }
//    }
//}

//// Triggering events repeatedly using a timer
//struct ContentView: View {
//    let timer = Timer.publish(every: 1, tolerance: 0.5, on: .main, in: .common).autoconnect()
//    @State private var counter = 0
//    
//    var body: some View {
//        Text("Hello")
//            .onReceive(timer) { time in
//                if counter == 5 {
//                    timer.upstream.connect().cancel()
//                } else {
//                    print("The time is now \(time)")
//                }
//                
//                counter += 1
//            }
//    }
//}

//// Disabling user interactivity with allowsHitTesting()
//struct ContentView: View {
//    var body: some View {
//        VStack {
//            Text("Hello")
//            Spacer().frame(height: 100)
//            Text("World")
//        }
//        // Set content shape to force a tap on the area generated by the Spacer to be tappable
//        .contentShape(Rectangle())
//        .onTapGesture {
//            print("VStack tapped!")
//        }
//        
////        ZStack {
////            Rectangle()
////                .fill(.blue)
////                .frame(width: 300, height: 300)
////                .onTapGesture {
////                    print("Rectangle tapped!")
////                }
////            
////            Circle()
////                .fill(.red)
////                .frame(width: 300, height: 300)
////                // Set content shape to explicitly set the area that the tap gesture will respond to
////                .contentShape(Rectangle())
////                .onTapGesture {
////                    print("Circle tapped!")
////                }
////                // Set allowsHitTesting to false to prevent the tap gesture from responding
//////                .allowsHitTesting(false)
////        }
//    }
//}

//// Making vibrations with Core Haptics
//struct ContentView: View {
//    @State private var engine: CHHapticEngine?
//    
//    var body: some View {
//        Text("Hello, world!")
////            .padding()
////            .onTapGesture(perform: simpleSuccess)
//            .onAppear(perform: prepareHaptics)
//            .onTapGesture(perform: complexSuccess)
//    }
//    
//    func simpleSuccess() {
//        let generator = UINotificationFeedbackGenerator()
//        generator.notificationOccurred(.success)
//    }
//    
//    func prepareHaptics() {
//        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }
//        
//        do {
//            engine = try CHHapticEngine()
//            try engine?.start()
//        } catch {
//            print("There was an error creating the engine: \(error.localizedDescription)")
//        }
//    }
//    
//    func complexSuccess() {
//        guard CHHapticEngine.capabilitiesForHardware().supportsHaptics else { return }
//        
//        var events = [CHHapticEvent]()
//        
//        for i in stride(from: 0, to: 1, by: 0.1) {
//            let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: Float(i))
//            let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: Float(i))
//            let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: i)
//            events.append(event)
//        }
//        
//        for i in stride(from: 0, to: 1, by: 0.1) {
//            let intensity = CHHapticEventParameter(parameterID: .hapticIntensity, value: Float(1 - i))
//            let sharpness = CHHapticEventParameter(parameterID: .hapticSharpness, value: Float(1 - i))
//            let event = CHHapticEvent(eventType: .hapticTransient, parameters: [intensity, sharpness], relativeTime: 1 + i)
//            events.append(event)
//        }
//        
//        do {
//            let pattern = try CHHapticPattern(events: events, parameters: [])
//            let player = try engine?.makePlayer(with: pattern)
//            try player?.start(atTime: 0)
//        } catch {
//            print("Failed to play pattern \(error.localizedDescription)")
//        }
//    }
//}

//// How to use gestures in SwiftUI
//struct ContentView: View {
//    // Custom long press to drag gesture
//    @State private var offset = CGSize.zero
//    @State private var isDragging = false
//    
//    // Scale
////    @State private var currentAmount = 0.0
////    @State private var finalAmount = 1.0
//    // Rotation
////    @State private var currentAmount = Angle.zero
////    @State private var finalAmount = Angle.zero
//    
//    var body: some View {
//        let dragGesture = DragGesture()
//            .onChanged { value in
//                offset = value.translation
//            }
//            .onEnded { _ in
//                withAnimation {
//                    offset = .zero
//                    isDragging = false
//                }
//            }
//        
//        let pressGesture = LongPressGesture()
//            .onEnded { value in
//                withAnimation {
//                    isDragging = true
//                }
//            }
//        
//        let combined = pressGesture.sequenced(before: dragGesture)
//        
//        Circle()
//            .fill(.red)
//            .frame(width: 64, height: 64)
//            .scaleEffect(isDragging ? 1.5 : 1)
//            .offset(offset)
//            .gesture(combined)
//        
//        // Tap
////        VStack {
////            Image(systemName: "globe")
////                .imageScale(.large)
////                .foregroundStyle(.tint)
////            Text("Hello, world!")
////                .onTapGesture {
////                    print("Text tapped!")
////                }
////        }
////            .onTapGesture(count: 2) {
////                print("Double tapped")
////            }
////            .onLongPressGesture(minimumDuration: 1) {
////                print("Long pressed!")
////            } onPressingChanged: { inProgress in
////                print("In progress: \(inProgress)")
////            }
//        // Child tap gesture on Text will be preferred over gestures on outer elements unless there is a high priority gesture used
////        .highPriorityGesture(
//        // Simultaneous gesture can be used to allow both gestures to activate at once
////        .simultaneousGesture(
////            TapGesture()
////                .onEnded {
////                    print("VStack tapped")
////                }
////        )
//        // Scale
////        .scaleEffect(finalAmount + currentAmount)
////        .gesture(
////            MagnificationGesture()
////                .onChanged { amount in
////                    currentAmount = amount - 1
////                }
////                .onEnded { amount in
////                    finalAmount += currentAmount
////                    currentAmount = 0
////                }
////        )
//        // Rotation
////        .rotationEffect(currentAmount + finalAmount)
////        .gesture(
////            RotationGesture()
////                .onChanged { angle in
////                    currentAmount = angle
////                }
////                .onEnded { angle in
////                    finalAmount += currentAmount
////                    currentAmount = .zero
////                }
////        )
//    }
//}

#Preview {
    ContentView()
}
